<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* #content {
            width: 100px;
            height: 100px;
            background: red;
            position: absolute;
        } */
        html,
        body {
            height: 100%;
            width: 100%;
            background-color:#cccccc;
        }

        #main {
            height: 800px;
            width: 100%;
            overflow-y: scroll;
            position: relative;
        }

        .obox {
            width: 200px;
            position: absolute;
            border:3px solid #ffffff;
        }
    </style>
</head>

<body>
    <!-- <div id="content">

    </div> -->
    <div id="main">

    </div>
</body>
<script type="text/javascript">
    //瀑布流
    var arr = [];//定义一个数组，用来存储元素的高度
    let dom = document.getElementById('main')
    let cloumn = parseInt(dom.clientWidth / 200)
    var scrollIndex = 0
    function reload(index) {
        for (let i = 0; i < 100; i++) {
            let domChild = document.createElement('div')
            domChild.setAttribute('class', 'obox')
            let height = Math.floor(Math.random() * 100)
            domChild.style.height = height + 'px'
            domChild.style.backgroundColor = `rgba(${Math.random() * 255},${Math.random() * 255},${Math.random() * 255})`
            dom.appendChild(domChild)
        }
    }
    function change(scrollIndex) {
        let divChild = document.getElementsByClassName('obox')
        for (let j = scrollIndex * 100; j < divChild.length; j++) {
            if (j < cloumn) {
                divChild[j].style.left = (200 + 10) * j + 'px'
                divChild[j].style.top = 0
                arr.push(divChild[j].offsetHeight);
            } else {
                let minIndex = Math.min.apply(null, arr);
                var index = 0
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] == minIndex) {
                        index = i
                    }
                }
                divChild[j].style.top = arr[index] + 10 + 'px'
                divChild[j].style.left = divChild[index].offsetLeft + 'px'
                arr[index] = arr[index] + divChild[j].offsetHeight + 10
            }
        }
    }
    window.onload = function () {
        reload(0)
        change(0)
    }
    //按需加载//分页的形式也不是懒加载
    dom.addEventListener('scroll', function () {
        let minIndex = Math.min.apply(null, arr);
        if ((dom.scrollTop + dom.clientHeight) - minIndex > 10) {
            scrollIndex++
            reload(scrollIndex)
            change(scrollIndex)
        }
    })

















    //拖拽
    // window.onload = function () {
    //     //拖拽功能(主要是触发三个事件：onmousedown\onmousemove\onmouseup) 
    //     var drag = document.getElementById('content');
    //     //点击某物体时，用drag对象即可，move和up是全局区域，也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动) 
    //     drag.onmousedown = function (e) {
    //         var e = e || window.event; //兼容ie浏览器 
    //         var diffX = e.clientX - drag.offsetLeft; //鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离 
    //         var diffY = e.clientY - drag.offsetTop;
    //         /*低版本ie bug:物体被拖出浏览器可是窗口外部时，还会出现滚动条， 
    //           解决方法是采用ie浏览器独有的2个方法setCapture()\releaseCapture(),这两个方法， 
    //           可以让鼠标滑动到浏览器外部也可以捕获到事件，而我们的bug就是当鼠标移出浏览器的时候， 
    //           限制超过的功能就失效了。用这个方法，即可解决这个问题。注：这两个方法用于onmousedown和onmouseup中*/
    //         if (typeof drag.setCapture != 'undefined') {
    //             drag.setCapture();
    //         }
    //         document.onmousemove = function (e) {
    //             var e = e || window.event; //兼容ie浏览器 
    //             var left = e.clientX - diffX;
    //             var top = e.clientY - diffY;
    //             //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条 
    //             if (left < 0) {
    //                 left = 0;
    //             } else if (left > window.innerWidth - drag.offsetWidth) {
    //                 left = window.innerWidth - drag.offsetWidth;
    //             }
    //             if (top < 0) {
    //                 top = 0;
    //             } else if (top > window.innerHeight - drag.offsetHeight) {
    //                 top = window.innerHeight - drag.offsetHeight;
    //             }
    //             //移动时重新得到物体的距离，解决拖动时出现晃动的现象 
    //             drag.style.left= left + 'px';
    //             drag.style.top = top + 'px';
    //         };
    //         document.onmouseup = function (e) { //当鼠标弹起来的时候不再移动 
    //             this.onmousemove = null;
    //             this.onmouseup = null; //预防鼠标弹起来后还会循环（即预防鼠标放上去的时候还会移动） 
    //             //修复低版本ie bug 
    //             if (typeof drag.releaseCapture != 'undefined') {
    //                 drag.releaseCapture();
    //             }
    //         };
    //     };
    // };

</script>

</html>